package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.26

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/humgal/art-server/auth"
	"github.com/humgal/art-server/dao/users"
	"github.com/humgal/art-server/graph/model"
	"github.com/humgal/art-server/service"
	"github.com/humgal/art-server/util/jwt"
	"github.com/humgal/art-server/util/redis"
)

// NewUser is the resolver for the newUser field.
func (r *mutationResolver) NewUser(ctx context.Context, user *model.NewUser) (string, error) {
	var userdao users.User
	userdao.Username = user.Username
	userdao.Password = user.Password
	if user.Email != nil {
		userdao.Email = user.Email
	}
	if user.Phone != nil {
		userdao.Phone = user.Phone
	}
	res, err := userdao.Create()
	if res {
		return "success", nil
	} else {
		return "fail", err
	}
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, user *model.UpdateUser) (string, error) {
	username := auth.ForContext(ctx)
	if username == nil {
		return "fail", fmt.Errorf("access denied")
	} else {
		return service.UpdateUser(user, username.Username)
	}
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.Login) (string, error) {
	loginstat := auth.IpContext(ctx)
	redisloginstat := users.LoginStatus{}
	var loginstatbyte []byte
	redis.Rdb.HGet(redis.Rdb.Context(), "openart:user:login", input.Username).Scan(&loginstatbyte)
	json.Unmarshal(loginstatbyte, &redisloginstat)

	if redisloginstat.TodayNum > 2 {
		return "", errors.New("login forbidden")
	}
	const longForm = "2006-01-02 15:04:05"

	redisloginstattime, _ := time.Parse(longForm, redisloginstat.LoginTime)
	timeStr := time.Now().Format("2006-01-02")
	fmt.Println("timeStr:", timeStr)
	t, _ := time.Parse("2006-01-02", timeStr)
	if redisloginstattime.Before(t) {
		loginstat.TodayNum = 1
	} else {
		loginstat.TodayNum = redisloginstat.TodayNum + 1
	}

	var userdao users.User
	userdao.Username = input.Username
	userdao.Password = input.Password
	correct := userdao.Authenticate()
	if !correct {
		// 1
		return "", errors.New("username and password unmatch")
	}

	token, err := jwt.GenerateToken(userdao.Username)
	if err != nil {
		return "", err
	}
	statbyte, _ := json.Marshal(loginstat)

	redis.Rdb.HSet(redis.Rdb.Context(), "openart:user:login", input.Username, statbyte).Result()
	return token, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.RefreshTokenInput) (string, error) {
	username, err := jwt.ParseToken(input.Token)
	if err != nil {
		return "", fmt.Errorf("access denied")
	}

	token, err := jwt.GenerateToken(username)
	redis.Rdb.Del(redis.Rdb.Context(), input.Token)
	if err != nil {
		return "", err
	}
	return token, nil
}

// PlaceBid is the resolver for the placeBid field.
func (r *mutationResolver) PlaceBid(ctx context.Context, bid *model.BidParm) (*model.Bid, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return &model.Bid{}, fmt.Errorf("access denied")
	} else {
		return service.PlaceBid(bid)
	}
}

// UploadArt is the resolver for the uploadArt field.
func (r *mutationResolver) UploadArt(ctx context.Context, items []*model.UploadItem) ([]*model.Item, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	} else {
		return service.UploadArt(items)
	}
}

// SetPriceAndMint is the resolver for the setPriceAndMint field.
func (r *mutationResolver) SetPriceAndMint(ctx context.Context, param *model.PriceParam) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, fmt.Errorf("access denied")
	} else {
		return service.SetPrice(param)
	}
}

// CreateCollection is the resolver for the createCollection field.
func (r *mutationResolver) CreateCollection(ctx context.Context, param model.CollectionParm) (bool, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return false, fmt.Errorf("access denied")
	} else {
		return service.CreateCollection(param)
	}
}

// Checkout is the resolver for the checkout field.
func (r *mutationResolver) Checkout(ctx context.Context, param *model.PayParam) (*string, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	} else {
		return service.Checkout(param)
	}
}

// ConnectWallet is the resolver for the connectWallet field.
func (r *mutationResolver) ConnectWallet(ctx context.Context, userID string, typeArg model.WalletType) (*model.Wallet, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	} else {
		return service.ConnectWallet(userID, typeArg)
	}
}

// Follow is the resolver for the follow field.
func (r *mutationResolver) Follow(ctx context.Context, param *model.FollowParam) (*string, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	} else {
		return service.Follow(param)
	}
}

// SearchItems is the resolver for the searchItems field.
func (r *queryResolver) SearchItems(ctx context.Context, param model.SearchParm) ([]*model.Item, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	} else {
		return service.SearchItems(param)
	}
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	} else {
		return service.User(id)
	}
}

// Item is the resolver for the item field.
func (r *queryResolver) Item(ctx context.Context, id string) (*model.Item, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	} else {
		return service.Item(id)
	}
}

// Collection is the resolver for the collection field.
func (r *queryResolver) Collection(ctx context.Context, creator string) ([]*model.Collection, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	} else {
		return service.Collection(creator)
	}
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context, createor string) ([]*model.Item, error) {
	user := auth.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	} else {
		return service.Items(createor)
	}
}

// SubscriptionPayment is the resolver for the subscriptionPayment field.
func (r *subscriptionResolver) SubscriptionPayment(ctx context.Context, itemid *string) (<-chan *model.SubscriptionEvent, error) {
	panic(fmt.Errorf("not implemented: SubscriptionPayment - subscriptionPayment"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *subscriptionResolver) SubscriptionBid(ctx context.Context, itemid *string) (<-chan []*model.Bid, error) {
	panic(fmt.Errorf("not implemented: SubscriptionPayment - subscriptionPayment"))
}
